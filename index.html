<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Malvagiometro</title>

  <style>
    :root{ --paper:#f6e6c9; --ink:#22140f; --shadow: rgba(0,0,0,.25); }
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      background:var(--paper);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--ink);
    }
    .card{
      width:min(560px,94vw);
      background:rgba(255,255,255,.55);
      border:4px solid var(--ink);
      border-radius:22px;
      padding:14px;
      box-shadow:0 16px 40px var(--shadow);
    }
    .gaugeWrap{
      position:relative;
      width:100%;
      aspect-ratio:1/1;
      overflow:hidden;
      border-radius:16px;
      background:#fff2d9;

      /* perno (se serve, lo rifiniamo) */
      --px: 50%;
      --py: 60.2%;
    }
    .gaugeWrap img{
      width:100%; height:100%;
      object-fit:cover;
      display:block;
      user-select:none;
      -webkit-user-drag:none;
    }

    /* LANCETTA */
    .needle{
      position:absolute;
      left: var(--px);
      top:  var(--py);
      width: 42%;
      height: 18px;
      transform-origin: 0% 50%;
      transform: translateY(-50%) rotate(-165deg); /* zero */
      transition: transform 260ms ease-out;        /* rientro */
      filter: drop-shadow(2px 3px 0 rgba(0,0,0,.25));
      z-index:4;
      pointer-events:none;
    }
    .needle::before{
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(180deg, #e24a4a, #b81f24);
      border:4px solid var(--ink);
      border-radius:999px;
      clip-path: polygon(0 0, 90% 0, 100% 50%, 90% 100%, 0 100%);
    }

    /* PERNO */
    .hub{
      position:absolute;
      left: var(--px);
      top: var(--py);
      width: 54px;
      height: 54px;
      transform: translate(-50%,-50%);
      background: radial-gradient(circle at 35% 35%, #ffe9a8, #f0b84f);
      border:6px solid var(--ink);
      border-radius:50%;
      box-shadow:0 10px 0 rgba(0,0,0,.12);
      z-index:5;
      pointer-events:none;
    }

    /* BOTTONE ROSSO SEMPLICE */
    button{
      width:100%;
      margin-top:12px;
      padding:16px 12px;
      border-radius:16px;
      border:5px solid var(--ink);
      background:#d6252c;
      color:#fff;
      font-weight:1000;
      letter-spacing:.9px;
      text-transform:uppercase;
      cursor:pointer;
      box-shadow:0 14px 0 rgba(0,0,0,.18);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button:active{ transform: translateY(4px); box-shadow:0 10px 0 rgba(0,0,0,.18); }
  </style>
</head>

<body>
  <div class="card">
    <div class="gaugeWrap">
      <img src="gauge.PNG" alt="Malvagiometro" />
      <div class="needle" id="needle"></div>
      <div class="hub"></div>
    </div>

    <button id="btn">MISURA (TIENI PREMUTO)</button>
  </div>

<script>
  const needle = document.getElementById("needle");
  const btn = document.getElementById("btn");

  // ---- ANGOLI ----
  const ZERO_DEG = -165;

  const levels = [
    { a0: -170, a1: -130 }, // Angioletta
    { a0: -130, a1: -90  }, // Birbantella
    { a0: -90,  a1: -50  }, // Disonesta
    { a0: -50,  a1: -15  }, // Bandita
    { a0: -15,  a1:  10  }  // Signora oscura
  ];

  const rand  = (min,max) => min + Math.random()*(max-min);
  const clamp = (x,a,b) => Math.max(a, Math.min(b, x));

  // ---- AUDIO: Geiger (noise + tick metallico) ----
  let audioCtx = null;
  let noiseBuf = null;

  function ensureAudio(){
    if(!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if(audioCtx.state === "suspended") audioCtx.resume();

    if(!noiseBuf){
      const len = Math.floor(audioCtx.sampleRate * 0.06); // 60 ms
      const buffer = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for(let i=0;i<len;i++){
        data[i] = (Math.random()*2 - 1) * 0.7; // rumore un pelo più “presente”
      }
      noiseBuf = buffer;
    }
    return audioCtx;
  }

  // Click Geiger: burst di rumore (bandpass) + "tink" metallico (sine breve)
  function geigerClick(intensity=1){
    const ctx = ensureAudio();
    const t = ctx.currentTime;

    // --- rumore ---
    const src = ctx.createBufferSource();
    src.buffer = noiseBuf;

    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = 2300 + Math.random()*1100;
    bp.Q.value = 7 + Math.random()*3;

    const gN = ctx.createGain();
    const peakN = 0.08 * intensity;
    gN.gain.setValueAtTime(0.0001, t);
    gN.gain.exponentialRampToValueAtTime(peakN, t + 0.002);
    gN.gain.exponentialRampToValueAtTime(0.0001, t + 0.028);

    src.connect(bp).connect(gN).connect(ctx.destination);
    src.start(t);
    src.stop(t + 0.06);

    // --- tick metallico ---
    const o = ctx.createOscillator();
    const gT = ctx.createGain();
    o.type = "sine";

    // frequenza tipo "tink": 2.8–4.2 kHz
    const f = 2800 + Math.random()*1400;
    o.frequency.setValueAtTime(f, t);

    // decadimento rapido
    const peakT = 0.045 * intensity;
    gT.gain.setValueAtTime(0.0001, t);
    gT.gain.exponentialRampToValueAtTime(peakT, t + 0.001);
    gT.gain.exponentialRampToValueAtTime(0.0001, t + 0.018);

    o.connect(gT).connect(ctx.destination);
    o.start(t);
    o.stop(t + 0.02);
  }

  // ---- VIBRAZIONE (Android sì, iPhone quasi mai) ----
  function vib(pattern){
    if("vibrate" in navigator){
      try { navigator.vibrate(pattern); } catch(_) {}
    }
  }

  // ---- GEIGER NEEDLE ----
  let currentDeg = ZERO_DEG;
  let targetDeg  = ZERO_DEG;

  let geigerTimer = null;
  let settleTimer = null;
  let holding = false;

  // per non vibrare 200 volte mentre “aggancia” il target
  let vibbedThisHold = false;

  function setNeedleInstant(deg){
    currentDeg = deg;
    needle.style.transition = "none";
    needle.style.transform = `translateY(-50%) rotate(${deg}deg)`;
  }
  function setNeedleSmooth(deg, ms=260){
    currentDeg = deg;
    needle.style.transition = `transform ${ms}ms ease-out`;
    needle.style.transform = `translateY(-50%) rotate(${deg}deg)`;
  }
  function stopGeiger(){
    if(geigerTimer){ clearTimeout(geigerTimer); geigerTimer = null; }
    if(settleTimer){ clearTimeout(settleTimer); settleTimer = null; }
  }

  function randomTarget(){
    const i = Math.floor(Math.random() * levels.length);
    const lv = levels[i];
    return rand(lv.a0, lv.a1) + rand(-2, 2);
  }

  // Loop irregolare (setTimeout) = più realistico del setInterval
  function geigerLoop(){
    const dist = targetDeg - currentDeg;

    // 0..1: più “a destra” (più cattivo) => più frequente e più forte
    const danger = clamp((targetDeg + 170) / 180, 0, 1);

    // vicino al target: vibra attorno
    if(Math.abs(dist) < 2.2){
      const jitter = rand(-1.8, 1.8);
      const d = clamp(targetDeg + jitter, -180, 15);
      needle.style.transform = `translateY(-50%) rotate(${d}deg)`;

      // click più sporadici in “idle”
      if(Math.random() < (0.22 + 0.35*danger)) geigerClick(0.75 + 0.8*danger);

      // vibrazione “arrivato al risultato” se è cattivo
      // soglia: Bandita/Signora oscura circa target > -35
      if(!vibbedThisHold && targetDeg > -35){
        vibbedThisHold = true;
        vib([20, 30, 20]); // piccolo tremolio
      }

      if(!holding){
        stopGeiger();
        settleTimer = setTimeout(() => setNeedleSmooth(ZERO_DEG, 320), 220);
        return;
      }
    } else {
      // scatti verso il target
      const step = clamp(Math.abs(dist) * 0.22, 1.2, 10.0);
      const dir = Math.sign(dist);
      const micro = rand(-0.9, 0.9);

      const next = currentDeg + dir * step + micro;
      currentDeg = next;
      needle.style.transform = `translateY(-50%) rotate(${next}deg)`;

      // click quasi sempre durante salita
      if(Math.random() < 0.88) geigerClick(0.85 + 1.0*danger);

      // se davvero “scuro”, vibra anche durante la salita (rara, per non scassare)
      if(danger > 0.82 && Math.random() < 0.08) vib(12);
    }

    // timing: più cattivo => più rapido
    const base = 55 - Math.floor(30 * danger); // 55..25 ms
    const delay = Math.floor(rand(base*0.7, base*1.25));
    geigerTimer = setTimeout(geigerLoop, delay);
  }

  function startGeigerTo(target){
    stopGeiger();
    targetDeg = target;
    needle.style.transition = "none";
    vibbedThisHold = false;
    geigerLoop();
  }

  // ---- INTERAZIONE: hold / release ----
  function onPressStart(ev){
    ev.preventDefault();
    holding = true;
    ensureAudio();               // sblocca audio su iOS
    startGeigerTo(randomTarget());
  }

  function onPressEnd(){
    if(!holding) return;
    holding = false;
    stopGeiger();
    setNeedleSmooth(ZERO_DEG, 420);
  }

  btn.addEventListener("pointerdown", onPressStart);
  btn.addEventListener("pointerup", onPressEnd);
  btn.addEventListener("pointercancel", onPressEnd);
  btn.addEventListener("pointerleave", onPressEnd);

  btn.addEventListener("touchstart", onPressStart, { passive:false });
  btn.addEventListener("touchend", onPressEnd);
  btn.addEventListener("touchcancel", onPressEnd);

  setNeedleInstant(ZERO_DEG);
</script>
</body>
</html>
